{
    "collab_server" : "",
    "contents" : "---\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\nlibrary(ggplot2)\n```\n\n<h2 text align = \"center\">Лабораторная работа №3.</h2>\n\n<h2 text align = \"center\">Условная оптимизация ФНП.</h2>\n\n<h4 text align = \"center\">Вариант 17</h4>\n\n<h3>Задание:</h3>\n\n<p>\nФункция:\n<br>\nf(x,y) = 10 * (x + y<sup>2</sup>)<sup>2</sup> + (1 - x)<sup>2</sup>\n<br><br>\nОграничения:\n<br>\nw<sub>1</sub>(x, y) = 3 * x + 2 * y - 6 >= 0 \n<br>\nw<sub>2</sub>(x, y) = 8 * x<sup>2</sup> + 2 * y<sup>2</sup> - 25 > 0\n<br><br>\nНайти минимум функции с точностью e = 0,001 по спроектированному вектору градиента.\n</p>\n\n<h3>Метод наискорейшего градиентного спуска 1:</h3>\n\n<h5>Графики функций:</h5>\n\n```{r, echo=FALSE}\n# Параметры для графиков\n\nr = 4\nx = seq(0, 5, by = 0.05)\ny = seq(-5, 5, by = 0.05)\n\n# Функции для графиков\n\nf = function(x, y) { 10 * (x + y ^ 2) ^ 2 + (1 - x) ^ 2 }\n\nw1 = function(x, y) { 3 * x + 2 * y - 6 }\n\nw2 = function(x, y) { 8 * x ^ 2 + 2 * y ^ 2 - 25 }\n\nP1 = function(x, y) {\n  p1 = w1(x, y)\n  p1[w1(x, y) < 0] = 10 ^ r\n  p1[w1(x, y) >= 0] = 0\n  return(p1)\n}\n\nP2 = function(x, y) {\n  p2 = w2(x, y)\n  p2[w2(x, y) <= 0] = 10 ^ r\n  p2[w2(x, y) > 0] = 0\n  return(p2)\n}\n\nP = function(x, y) {\n    p3 = P1(x, y) + P2(x, y)\n    p3[p3 > 0] = 10 ^ r\n    return(p3)\n}\n\nF = function(x, y) {\n    func = f(x, y) + P(x, y)\n    func[P(x, y) > 0] = 10 ^ r\n    return(func)\n}\n\n# Графики\n\ngrd = expand.grid(x = x,y = y)\ngrd$z = with(grd, F(x, y))\ngpl = ggplot() + geom_contour(data = grd, aes(x = x, y = y, z = z))\n\nff = outer(x, y, f)\nPP1 = outer(x, y, P1)\nPP2 = outer(x, y, P2)\nPP = outer(x, y, P)\nFF = outer(x, y, F)\n\njet.colors = colorRampPalette(c(\"#00007F\", \"blue\", \"#007FFF\", \"cyan\", \"#7FFF7F\", \"yellow\", \"#FF7F00\", \"red\", \"#7F0000\"))\ncolor = jet.colors(100)\n\nnrz = nrow(ff)\nncz = ncol(ff)\nzfacet = ff[-1, -1] + ff[-1, -ncz] + ff[-nrz, -1] + ff[-nrz, -ncz]\nfacetcol = cut(zfacet, 100)\n\nnrz1 = nrow(PP1)\nncz1 = ncol(PP1)\nzfacet1 = PP1[-1, -1] + PP1[-1, -ncz1] + PP1[-nrz1, -1] + PP1[-nrz1, -ncz1]\nfacetcol1 = cut(zfacet1, 100)\n\nnrz2 = nrow(PP2)\nncz2 = ncol(PP2)\nzfacet2 = PP2[-1, -1] + PP2[-1, -ncz2] + PP2[-nrz2, -1] + PP2[-nrz2, -ncz2]\nfacetcol2 = cut(zfacet2, 100)\n\nnrz4 = nrow(FF)\nncz4 = ncol(FF)\nzfacet3 = FF[-1, -1] + FF[-1, -ncz4] + FF[-nrz4, -1] + FF[-nrz4, -ncz4]\nfacetcol3 = cut(zfacet3, 100)\n\npar(mfrow = c(1, 2))\n\npersp(x, y, z = ff, phi = 20, theta = 120, expand = 0.5, ticktype = \"detail\", xlab = \"X\", ylab = \"Y\", zlab = \"Z\", main = \"f = 10 * (x + y ^ 2) ^ 2 + (1 - x) ^ 2\", col = color[facetcol])\n\npersp(x, y, z = FF, phi = 20, theta = 120, expand = 0.5, ticktype = \"detail\", xlab = \"X\", ylab = \"Y\", zlab = \"Z\", main = \"F = f + P1 + P2\", col = color[facetcol3])\n\npersp(x, y, z = PP1, phi = 20, theta = 120, expand = 0.5, ticktype = \"detail\", xlab = \"X\", ylab = \"Y\", zlab = \"Z\", main = \"P1   3 * x + 2 * y - 6 >= 0\", col = color[facetcol1])\n\npersp(x, y, z = PP2, phi = 20, theta = 120, expand = 0.5, ticktype = \"detail\", xlab = \"X\", ylab = \"Y\", zlab = \"Z\", main = \"P2   8 * x ^ 2 + 2 * y ^ 2 - 25 > 0\", col = color[facetcol2])\n\n# filled.contour(x, y, ff, col = rainbow(20), nlevels = 20)\n# filled.contour(x, y, PP1, col = rainbow(20), nlevels = 20)\n# filled.contour(x, y, PP2, col = rainbow(40), nlevels = 40)\n# filled.contour(x, y, PP, col = rainbow(20), nlevels = 20)\n# filled.contour(x, y, FF, col = rainbow(7), nlevels = 7)\n\n```\n\n```{r, include=FALSE}\n# функции для градиентного спуска\n\n# D(expression(10 * (x + y ^ 2) ^ 2 + (1 - x) ^ 2), \"x\")\n# D(expression(10 * (x + y ^ 2) ^ 2 + (1 - x) ^ 2), \"y\")\n# prx = 20 * (x + y^2)) - 2 * (1 - x)\n# pry = 40 * y * (x + y^2)))\n\nfun_gr_f = function(r) {                                      # градиент в точке для f\n    return(c(20 * (r[1] + r[2] ^ 2) - 2 * (1 - r[1]), 40 * r[2] * (r[1] + r[2] ^ 2)))\n}\n\nfun_norm_gr = function(grad) {                                     # нормирование градиента\n    glen = sqrt(grad[1] ^ 2 + grad[2] ^ 2)\n    gnorm = grad / glen\n    return(gnorm)\n} \n\nfun_r_gr = function(step, r1, grad) {                              # точка по градиенту\n    return(c(r1[1] - step * grad[1], r1[2] - step * grad[2]))\n}\n\nfun_r_st = function(step, r1, r2) {                              # точка по шагу\n    deltar = c(r2[1] - r1[1], r2[2] - r1[2])\n    return(c(r1[1] + step * deltar[1], r1[2] + step * deltar[2]))\n}\n\nfun_f_st = function(step, r1, r2) {                              # функция f(st)\n    del_r = c(r2[1] - r1[1], r2[2] - r1[2])\n    return(10 * ((r1[1] + step * del_r[1]) + (r1[2] + step * del_r[2]) ^ 2) ^ 2 + (1 - (r1[1] + step * del_r[1])) ^ 2)\n}\n\nfun_f_r = function(r) {                                       # значение функции f(r)\n    return(10 * (r[1] + r[2] ^ 2) ^ 2 + (1 - r[1]) ^ 2)\n}\n\nfun_w1 = function(r) {                                       # 1 штрафная функция\n    if ((3 * r[1] + 2 * r[2] - 6) >= 0) return(1)\n    else return(0)\n}\n\nfun_w2 = function(r) {                                       # 2 штрафная функция\n    if ((8 * r[1] ^ 2 + 2 * r[2] ^ 2 - 25) > 0) return(1)\n    else return(0)\n}\n\nfun_gr_w1 = function() {                                     # градиент в точке для w1\n    return(c(3, 2))\n}\n\nfun_gr_w2 = function(r) {                                     # градиент в точке для w2\n    return(c(16 * r[1], 4 * r[2]))\n}\n\nfun_mod = function(grad) {\n    mod = sqrt(grad[1] ^ 2 + grad[2] ^ 2)\n    return(mod)\n}\n\nw1 = function(r) { 3 * r[1] + 2 * r[2] - 6 }\n\n```\n\n<h5>Исходные параметры:</h5>\n\n```{r}\n\nr0 = c(3, 5)                                            # начальное приближение\nconesc = 0.001                                               # условие выхода\nst2 = 1                                                   # шаг для выхода\n\n```\n\n<h5>Код метода:</h5>\n\n```{r}\n\nr1 = r0                                                  # начальная точка\niter = 0                                                 # итерации\nesc = 1\nxvec = c()                                                  # векторы для графика\nyvec = c()\nresult = \"Минимум успешно найден.\"\n\nwhile (TRUE) {\n    if (esc < conesc) break\n    if (iter > 1000) {\n        result = \"Минимум не найден. Плохое начальное приближение.\"\n        break\n    }\n    iter = iter + 1\n    xvec[iter] = r1[1]\n    yvec[iter] = r1[2]\n    grad = fun_norm_gr(fun_gr_f(r1))\n    r2 = fun_r_gr(st2, r1, grad)\n    while (TRUE) {\n        if (fun_w1(r2) * fun_w2(r2)) break\n        st2 = st2 * 0.9\n        r2 = fun_r_gr(st2, r1, grad)\n    }\n    opt = optimize(fun_f_st, interval = c(0, 1), r1 = r1, r2 = r2, lower = 0.001)\n    st1 = opt$minimum\n    r1 = fun_r_st(st1, r1, r2)\n    \n    #esc = w1(r2) \n    \n    f1 = fun_gr_f(r1)\n    w1 = fun_gr_w1()\n    # \n    cos = (f1[1] * w1[1] + f1[2] * w1[2]) / (fun_mod(f1) * fun_mod(w1))\n    lam = (fun_mod(f1) * cos) / fun_mod(w1)\n    esc = fun_mod(f1 - lam * w1)\n}\n\n```\n\n```{r, echo=FALSE}\n\nresult\n\n```\n\n\n<h5>Количество итераций:</h5>\n\n```{r, echo=FALSE}\n\niter\n\n```\n\n<h5>Точка минимума:</h5>\n\n```{r, echo=FALSE}\n\nc(xvec[iter], yvec[iter])\n\n```\n\n<h5>Значение функции в точке минимума:</h5>\n\n```{r, echo=FALSE}\n\nfun_f_r(c(xvec[iter], yvec[iter]))\n\n```\n\n<h5>График метода:</h5>\n\n```{r, echo=FALSE}\n\ngpl + geom_path(aes(xvec, yvec))\n\n```\n\n<h3>Выводы:</h3>\n<p>Данная задача была решена без применения функции пенальти, однако, в связи с трудностью определения критерия выхода и проблемами с универсальностью, предпочтительнее использовать метод с функцией пенальти. В данном случае критерием выхода служит величина функции-ограничителя. Также критерием выхода может послужить величина шага.</p>",
    "created" : 1480097181646.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1616829391",
    "id" : "E228A860",
    "lastKnownWriteTime" : 1481181478,
    "last_content_update" : 1481181478146,
    "path" : "~/Documents/Programs/R/MetOpt/Project_3/Project_3.Rmd",
    "project_path" : "Project_3.Rmd",
    "properties" : {
        "docOutlineVisible" : "0",
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}