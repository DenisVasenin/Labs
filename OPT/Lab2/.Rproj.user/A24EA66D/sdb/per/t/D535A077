{
    "collab_server" : "",
    "contents" : "---\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\nlibrary(ggplot2)\n```\n\n<h2 text align = \"center\">Лабораторная работа №2.</h2>\n\n<h2 text align = \"center\">Безусловная оптимизация ФНП.</h2>\n\n<h4 text align = \"center\">Вариант 17</h4>\n\n<h3>Задание:</h3>\n\n<p>\nf(x,y) = x<sup>2</sup> + 10 * y<sup>2</sup> - x * y - y\n<br> \nr<sub>0</sub> = (x<sub>0</sub>, y<sub>0</sub>) ;\n<br>\nx<sub>0</sub> = -2 ; y<sub>0</sub> = 2\n<br><br>\nИз начальной точки найти (локальный) оптимум функции с точностью e = 0,001.\n</p>\n\n```{r, echo=FALSE}\n\nx = c(rep(-5:5, 11))\ny = c(rep(-5:5, each = 11))\ndafr = data.frame(x, y)\nf = x ^ 2 + 10 * y ^ 2 - x * y - y\ndafr$z = with(dafr, f)\ngp = ggplot() + geom_contour(data = dafr, aes(x = x, y = y, z = z))\n\n```\n\n<h3>Метод наискорейшего градиентного спуска:</h3>\n\n```{r, echo=FALSE}\n# функции для градиентного спуска\n\ngrad = function(r) {                                     # градиент\n    return(c(2 * r[1] - r[2], 20 * r[2] - r[1] - 1))\n}\n\nrg = function(hg, r1, gr) {                              # точка по градиенту\n    return(c(r1[1] - hg * gr[1], r1[2] - hg * gr[2]))\n}\n\nrh = function(ha, r1, r2) {                              # точка по шагу\n    dr = c(r2[1] - r1[1], r2[2] - r1[2])\n    return(c(r1[1] + ha * dr[1], r1[2] + ha * dr[2]))\n}\n\nfh = function(ha, r1, r2) {                              # функция f(a)\n    dr = c(r2[1] - r1[1], r2[2] - r1[2])\n    return((r1[1] + ha * dr[1]) ^ 2 + 10 * (r1[2] + ha * dr[2]) ^ 2 - (r1[1] + ha * dr[1]) * (r1[2] + ha * dr[2]) - (r1[2] + ha * dr[2]))\n}\n\nfr = function(r) {                                       # функция f(r)\n    return(r[1] ^ 2 + 10 * r[2] ^ 2 - r[1] * r[2] - r[2])\n}\n\n```\n\n<h5>Исходные параметры:</h5>\n\n```{r}\n\nr0 = c(-2, 2)                                            # исходная точка\neg = 0.001                                               # точность по производной\nhg = 1                                                   # шаг для градиента\n\n```\n\n```{r}\n\nr1 = r0                                                  # начальная точка\niter = 0                                                 # итерации\ngrn = 1                                                  # для входа в цикл\nx = c()                                                  # векторы для графика\ny = c()\n\nwhile (TRUE) {\n    if (grn < eg) break \n    iter = iter + 1\n    x[iter] = r1[1]\n    y[iter] = r1[2]\n    gr = grad(r1) \n    r2 = rg(hg, r1, gr)\n    opt = optimize(fh, interval = c(0, 1), r1 = r1, r2 = r2, lower = 0.001)\n    ha = opt$minimum\n    r1 = rh(ha, r1, r2)\n    grn = sqrt(gr[1] ^ 2 + gr[2] ^ 2)\n}\n\n```\n\n<h5>Количество итераций:</h5>\n\n```{r, echo=FALSE}\n\niter\n\n```\n\n<h5>Точка минимума:</h5>\n\n```{r, echo=FALSE}\n\nr = c(x[iter], y[iter])\nr\n\n```\n\n<h5>Значение функции в точке минимума:</h5>\n\n```{r, echo=FALSE}\n\nf = fr(r)\nf\n\n```\n\n<h5>Модуль градиента в точке минимума:</h5>\n\n```{r, echo=FALSE}\n\ngrn\n\n```\n\n\n<h5>График:</h5>\n\n```{r, echo=FALSE}\n\ngp + geom_path(aes(x, y))\n\n```\n\n<h3>Метод Монте-Карло:</h3>\n\n```{r, echo=FALSE}\n# функции для Монте-Карло\n\nrp = function(h, r, R) {                               # новая точка по шагу\n    return(c(r[1] + h[1] * R, r[2] + h[2] * R))\n}\n\n```\n\n<h5>Исходные параметры:</h5>\n\n```{r}\n\nr0 = c(-2, 2)                                            # исходная точка\ner = 0.001                                               # минимальный размер области поиска\nQ = 60000                                                  # максимальное количество итераций\nR = 10                                                   # размер области поиска\nN = 10                                                   # количество точек на итерации\n\n```\n\n```{r}\n\nr1 = r0                                                  # начальная точка\niter = 0                                                 # итерации\ntrig = 0                                                 # триггер для уменьшения R\nh = c()                                                  # вектор для шага\nx = c(r1[1])                                             # векторы для графика\ny = c(r1[2])                                             # \n\nwhile (iter < Q & er < R) {\n    iter = iter + 1\n    trig = 0\n    rs = r1\n    for (i in 1:N) {\n        h = runif(2, -0.5, 0.5)\n        r = rp(h, rs, R)\n        if (fr(r) < fr(r1)) {\n            r1 = r\n            trig = 1\n        }\n    }\n    x[iter + 1] = r1[1]\n    y[iter + 1] = r1[2]\n    if (trig < 1) R = R * 0.5\n}\n\n```\n\n<h5>Количество итераций:</h5>\n\n```{r, echo=FALSE}\n\niter\n\n```\n\n\n<h5>Точка минимума:</h5>\n\n```{r, echo=FALSE}\n\nr1\n\n```\n\n<h5>Значение функции в точке минимума:</h5>\n\n```{r, echo=FALSE}\n\nf = fr(r1)\nf\n\n```\n\n<h5>Модуль градиента в точке минимума:</h5>\n\n```{r, echo=FALSE}\n\ngr = grad(r1) \nsqrt(gr[1] ^ 2 + gr[2] ^ 2)\n\n```\n\n\n<h5>График:</h5>\n\n```{r, echo=FALSE}\n\ngp + geom_path(aes(x, y))\n\n```\n\n",
    "created" : 1477207341784.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "817597789",
    "id" : "D535A077",
    "lastKnownWriteTime" : 1479592202,
    "last_content_update" : 1479592202208,
    "path" : "~/Documents/Programs/R/MetOpt/Project_2/Project_2.Rmd",
    "project_path" : "Project_2.Rmd",
    "properties" : {
        "docOutlineVisible" : "0",
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}